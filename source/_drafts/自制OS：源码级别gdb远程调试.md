# 自制OS：源码级别gdb远程调试

最近在学着编写一个操作系统的简单内核，需要debug工具，我们这里使用gdb来进行调试，由于虚拟机运行和本机是两个部分，所以使用 gdb 的远程调试技术，这里对 gdb 常见调试以及远程调试方式做一个总结。



## 远程调试

先对在调试操作系统内核时用到的命令做一个说明（这里省略了一部分makefile的内容）：

为了方便调试，将debug所用到的命令做一个简单说明

```makefile
……
# -s 这个参数指的是启动时开启1234端口等待gdb连接
# -S 是指是启动时不自动开始运行，等待调试器的执行命令
debug: kernel.elf os-image.bin
	@echo 🔨🔨🔨debug🔨🔨🔨
	${QEMU} -S -s -fda os-image.bin -boot a &
	i386-elf-gdb -q -ex "target remote localhost:1234" -ex "symbol-file kernel.elf"
	
……
```

我们在使用 qemu 启动运行镜像文件时，使用以下参数：

* -s 这个参数指的是启动时开启1234端口等待gdb连接
* S 是指是启动时不自动开始运行，等待调试器的执行命令

这个时候才开启了远程端口以便让我们后续能够进行连接到该端口进行调试

我们需要在编译源代码的时候，加上 `-g` 参数，以便能够将源代码信息编译到可执行文件中。

随后我们使用 gdb 开启调试

* `target remote localhost:1234` 连接到远程端口
* `symbol-file kernel.elf` 加载具有源代码信息编译到可执行文件

> `symbol-file 可以追踪到编译器提供的库和操作系统本身的代码
> 调试符号就是这些代码内的符号，调试符号数据库，
> 记录了变量，函数 这一类符号和内存定位的关系
> 从而可以用 地址相关信息追踪到变量名，函数名

之后我们就可以使用gdb命令来进行调试。

## 常见命令

| 命令                                                       |                             解释                             | 示例                                                         |
| :--------------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------- |
| [file](http://man.linuxde.net/file) <文件名>               | 加载被调试的可执行程序文件。 因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。 | (gdb) file gdb-sample                                        |
| r                                                          | Run的简写，运行被调试的程序。 如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。 | (gdb) r                                                      |
| c                                                          | continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 | (gdb) c                                                      |
| b <行号> b <函数名称> b *<函数名称> b *<代码地址> d [编号] | b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 | (gdb) b 8 (gdb) b main (gdb) b *main (gdb) b *0x804835c (gdb) d |
| s, n                                                       | s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； n: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”； n 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 | (gdb) s (gdb) n                                              |
| si, ni                                                     | si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。 | (gdb) si (gdb) ni                                            |
| p <变量名称>                                               |    Print的简写，显示指定变量（临时变量或全局变量）的值。     | (gdb) p i (gdb) p nGlobalVar                                 |
| display ... undisplay <编号>                               | display，设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i $pc” 其中 $pc 代表当前汇编指令，/i 表示以十六进制显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。 | (gdb) display /i $pc (gdb) undisplay 1                       |
| i                                                          | [info](http://man.linuxde.net/info)的简写，用于显示各类信息，详情请查阅“[help](http://man.linuxde.net/help) i”。 | (gdb) i r                                                    |
| q                                                          |                quit的简写，退出GDB调试环境。                 | (gdb) q                                                      |
| help [命令名称]                                            | GDB帮助命令，提供对GDB名种命令的解释说明。 如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。 | (gdb) help                                                   |



## 执行选项

- -cd：设置工作目录
- -q：安静模式，不打印介绍信息和版本信息
- -d：添加文件查找路径
- -x：从指定文件中执行GDB指令
- -s：设置读取的符号表文件

